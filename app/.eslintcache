[{"/Users/Matt/github/note-taker/app/src/index.js":"1","/Users/Matt/github/note-taker/app/src/App.js":"2","/Users/Matt/github/note-taker/app/src/reportWebVitals.js":"3","/Users/Matt/github/note-taker/app/src/TextEditor/TextEditor.js":"4","/Users/Matt/github/note-taker/app/src/TextEditor/CustomElements/CustomElements.js":"5","/Users/Matt/github/note-taker/app/src/TextEditor/CustomLeaves/CustomLeaves.js":"6"},{"size":500,"mtime":1608244512808,"results":"7","hashOfConfig":"8"},{"size":396,"mtime":1608248949327,"results":"9","hashOfConfig":"8"},{"size":362,"mtime":1608244512809,"results":"10","hashOfConfig":"8"},{"size":6895,"mtime":1608591005959,"results":"11","hashOfConfig":"8"},{"size":939,"mtime":1608588461550,"results":"12","hashOfConfig":"8"},{"size":275,"mtime":1608512400818,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},"d17dz7",{"filePath":"17","messages":"18","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"16"},{"filePath":"24","messages":"25","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"16"},{"filePath":"26","messages":"27","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"28"},"/Users/Matt/github/note-taker/app/src/index.js",[],["29","30"],"/Users/Matt/github/note-taker/app/src/App.js",[],"/Users/Matt/github/note-taker/app/src/reportWebVitals.js",[],"/Users/Matt/github/note-taker/app/src/TextEditor/TextEditor.js",["31","32"],"import React, { useState, useCallback, useMemo } from 'react'\nimport { Slate, Editable, withReact } from 'slate-react'\nimport {\n  Node,\n  Editor,\n  Transforms,\n  Range,\n  Point,\n  createEditor,\n  Text,\n  Element as SlateElement,\n} from 'slate'\nimport { withHistory } from 'slate-history'\n\n//CUSTOM ELEMENTS\nimport {\n  CodeBlock,\n  BlockQuote,\n  BulletedList,\n  NumberedList,\n  HeadingOne,\n  HeadingTwo,\n  HeadingThree,\n\n} from './CustomElements/CustomElements.js'\n\nimport { Leaf } from './CustomLeaves/CustomLeaves.js'\n\nconst CustomEditor = {\n  isBoldMarkActive(editor) {\n    const [match] = Editor.nodes(editor, {\n      match: n => n.bold === true,\n      universal: true,\n    })\n\n    return !!match\n  },\n\n  isCodeBlockActive(editor) {\n    const [match] = Editor.nodes(editor, {\n      match: n => n.type === 'code',\n    })\n\n    return !!match\n  },\n\n  toggleBoldMark(editor) {\n    const isActive = CustomEditor.isBoldMarkActive(editor)\n    Transforms.setNodes(\n      editor,\n      { bold: isActive ? null : true },\n      { match: n => Text.isText(n), split: true }\n    )\n  },\n\n  toggleCodeBlock(editor) {\n    const isActive = CustomEditor.isCodeBlockActive(editor)\n    Transforms.setNodes(\n      editor,\n      { type: isActive ? null : 'code' },\n      { match: n => Editor.isBlock(editor, n) }\n    )\n  },\n}\n\nconst MARKDOWNSHORTCUTS = {\n  '*': 'list-item',\n  '-': 'list-item',\n  '+': 'list-item',\n  '>': 'block-quote',\n  '#': 'heading-one',\n  '##': 'heading-two',\n  '###': 'heading-three',\n}\n\nconst initialValue = [\n  {\n    type: 'paragraph',\n    children: [\n      {\n        text:\n          'The editor gives you full control over the logic you can add. For example, it\\'s fairly common to want to add markdown-like shortcuts to editors. So that, when you start a line with \"> \" you get a blockquote that looks like this:',\n      },\n    ],\n  },\n  {\n    type: 'block-quote',\n    children: [{ text: 'A wise quote.' }],\n  },\n  {\n    type: 'paragraph',\n    children: [\n      {\n        text:\n          'Order when you start a line with \"## \" you get a level-two heading, like this:',\n      },\n    ],\n  },\n  {\n    type: 'heading-two',\n    children: [{ text: 'Try it out!' }],\n  },\n  {\n    type: 'paragraph',\n    children: [\n      {\n        text:\n          'Try it out for yourself! Try starting a new line with \">\", \"-\", or \"#\"s.',\n      },\n    ],\n  },\n]\n\nconst TextEditor = () => {\n  //const [value, setValue] = useState(initialValue || [])\n\n  const [value, setValue] = useState(\n    JSON.parse(localStorage.getItem('content')) || initialValue\n  )\n\n  const editor = useMemo(\n    () => withMarkdownShortcuts(withReact(withHistory(createEditor()))),\n    []\n  )\n\n  //FOR RENDERING CUSTOM BLOCKS\n  const DefaultElement = props => {\n    return <p {...props.attributes}>{props.children}</p>\n  }\n  const renderElement = useCallback(props => {\n    switch (props.element.type) {\n      case 'code':\n        return <CodeBlock {...props} />\n      case 'block-quote':\n        return <BlockQuote {...props}/>\n      case 'bulleted-list':\n        return <BulletedList {...props}/>\n        case 'list-item':\n          return <NumberedList {...props}/>\n      case 'heading-one':\n        return <HeadingOne {...props}/>\n      case 'heading-two':\n        return <HeadingTwo {...props}/>\n      case 'heading-three':\n        return <HeadingThree {...props}/>\n\n      default:\n        return <DefaultElement {...props} />\n    }\n  }, [])\n\n  const renderLeaf = useCallback(props => {\n    return <Leaf {...props} />\n  }, [])\n\n  return (\n    <Slate\n      editor={editor}\n      value={value}\n      onChange={value => {\n        setValue(value)\n\n        // Save the value to Local Storage.\n        const content = JSON.stringify(value)\n        localStorage.setItem('content', content)\n      }}\n    >\n      <Editable\n        renderElement={renderElement}\n        renderLeaf={renderLeaf}\n        onKeyDown={event => {\n          console.log(event)\n          let commandKey = event.ctrlKey || event.metaKey ? true : false\n          console.log(commandKey + \" pressed \" + event.key)\n          if (!commandKey) {\n            return\n          }\n\n          // Replace the `onKeyDown` logic with our new commands.\n          switch (event.key) {\n            case '`': {\n              event.preventDefault()\n              CustomEditor.toggleCodeBlock(editor)\n              break\n            }\n\n            case 'b': {\n              event.preventDefault()\n              CustomEditor.toggleBoldMark(editor)\n              break\n            }\n          }\n        }}\n      />\n    </Slate>\n  )\n}\n\nconst withMarkdownShortcuts = editor => {\n  const { deleteBackward, insertText } = editor\n\n  editor.insertText = text => {\n    const { selection } = editor\n\n    if (text === ' ' && selection && Range.isCollapsed(selection)) {\n      const { anchor } = selection\n      const block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n      const path = block ? block[1] : []\n      const start = Editor.start(editor, path)\n      const range = { anchor, focus: start }\n      const beforeText = Editor.string(editor, range)\n      const type = MARKDOWNSHORTCUTS[beforeText]\n\n      if (type) {\n        Transforms.select(editor, range)\n        Transforms.delete(editor)\n        const newProperties: Partial<SlateElement> = {\n          type,\n        }\n        Transforms.setNodes(editor, newProperties, {\n          match: n => Editor.isBlock(editor, n),\n        })\n\n        if (type === 'list-item') {\n          const list = { type: 'bulleted-list', children: [] }\n          Transforms.wrapNodes(editor, list, {\n            match: n =>\n              !Editor.isEditor(n) &&\n              SlateElement.isElement(n) &&\n              n.type === 'list-item',\n          })\n        }\n\n        return\n      }\n    }\n\n    insertText(text)\n  }\n\n  editor.deleteBackward = (...args) => {\n    const { selection } = editor\n\n    if (selection && Range.isCollapsed(selection)) {\n      const match = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n      })\n\n      if (match) {\n        const [block, path] = match\n        const start = Editor.start(editor, path)\n\n        if (\n          !Editor.isEditor(block) &&\n          SlateElement.isElement(block) &&\n          block.type !== 'paragraph' &&\n          Point.equals(selection.anchor, start)\n        ) {\n          const newProperties: Partial<SlateElement> = {\n            type: 'paragraph',\n          }\n          Transforms.setNodes(editor, newProperties)\n\n          if (block.type === 'list-item') {\n            Transforms.unwrapNodes(editor, {\n              match: n =>\n                !Editor.isEditor(n) &&\n                SlateElement.isElement(n) &&\n                n.type === 'bulleted-list',\n              split: true,\n            })\n          }\n\n          return\n        }\n      }\n\n      deleteBackward(...args)\n    }\n  }\n\n  return editor\n}\n\nexport default TextEditor\n","/Users/Matt/github/note-taker/app/src/TextEditor/CustomElements/CustomElements.js",[],"/Users/Matt/github/note-taker/app/src/TextEditor/CustomLeaves/CustomLeaves.js",[],["33","34"],{"ruleId":"35","replacedBy":"36"},{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","severity":1,"message":"40","line":4,"column":3,"nodeType":"41","messageId":"42","endLine":4,"endColumn":7},{"ruleId":"43","severity":1,"message":"44","line":180,"column":11,"nodeType":"45","messageId":"46","endLine":192,"endColumn":12},{"ruleId":"35","replacedBy":"47"},{"ruleId":"37","replacedBy":"48"},"no-native-reassign",["49"],"no-negated-in-lhs",["50"],"no-unused-vars","'Node' is defined but never used.","Identifier","unusedVar","default-case","Expected a default case.","SwitchStatement","missingDefaultCase",["49"],["50"],"no-global-assign","no-unsafe-negation"]